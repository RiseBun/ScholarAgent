# 修复 'Paper' object has no attribute 'paperId' 错误

## 问题分析

**错误原因**：在 `pages/1_🔍_Search.py` 中，代码尝试访问 `paper.paperId` 属性，但在 `backend/data_models.py` 中定义的 `Paper` 类没有这个属性。

**具体问题**：
- 原始论文数据（从API获取的）确实有 `paperId` 字段
- 但在 `backend/tagger.py` 中创建 `Paper` 对象时，没有包含这个字段
- 因此，当代码尝试访问 `paper.paperId` 时，会引发 `AttributeError`

## 解决方案

有三种可能的解决方案：

### 方案1：修改代码，只使用 title 作为唯一标识符
**优势**：
- 实现简单，风险最小
- 不需要修改 Paper 类的定义
- 与之前的代码逻辑一致（之前就是使用 title 作为唯一标识符）

**修改位置**：`pages/1_🔍_Search.py` 中的两处错误代码

### 方案2：在 Paper 类中添加 paperId 属性
**优势**：
- 更符合数据模型的完整性
- 可以使用更唯一的标识符

**修改位置**：
- `backend/data_models.py` 中的 Paper 类定义
- `backend/tagger.py` 中的 Paper 对象创建代码

### 方案3：使用 getattr() 函数处理不存在的属性
**优势**：
- 不需要修改数据模型
- 更加灵活

**修改位置**：`pages/1_🔍_Search.py` 中的错误代码

## 推荐方案

**推荐方案1**：修改代码，只使用 title 作为唯一标识符

**理由**：
- 实现最简单，风险最小
- 与之前的代码逻辑一致
- 不需要修改多个文件
- 能够快速解决当前错误

## 具体修改步骤

1. **修改第一处错误**：`pages/1_🔍_Search.py` 中的第445行
   - 将 `paper_id = paper.paperId or paper.title` 修改为 `paper_id = paper.title`

2. **修改第二处错误**：`pages/1_🔍_Search.py` 中的第545行左右（历史结果显示部分）
   - 将类似的 `paper.paperId` 访问修改为只使用 `paper.title`

## 预期效果

修复后，当用户搜索论文时，系统不会再因为尝试访问不存在的 `paperId` 属性而崩溃，能够正常显示搜索结果并允许用户收藏论文。